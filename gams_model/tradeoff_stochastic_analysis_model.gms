option LimCol = 0, LimRow = 0;

$onText
model and data description

residence data:
1. desired nbed, nbath, budget, com_m, com_t
2. nbed = 0 if the resident requires a studio

details:
1. com_t is an integer between 1-5, where 1-> t<5, 2-> 5<=t<10, ... 5-> t>25;
2. com_m is an integer between 1-3, where 1-> drive, 2-> walk, 3-> bike;
3. budget generated by normal distribution, mean=1200, delta=200;
4. extracted from gdx files: small_data, medium_data, large_data;
5. headr: /'nbed', 'nbath', 'budget', 'com_m', 'com_t'/
6. data: data(small/medium/large, headr);
7. small=30, medium=60, large=100;
8. need to figure out ranking -- currently a rand number form uniform(0,1) assigned to each label;

apartments data:
1. should have the same headr;
2. about commute methods: m1 for driving, m2 for walking, m3 for biking.

$offText

********************** Read in data **********************

set headr(*);
set r /1*30/;
alias(r2, r);
set a /a1*a63/;

parameter pairs;
pairs = min(card(r), card(a));

parameter res_data_original(r,headr), res_data(r,headr);
parameter rank_original(r, headr), rank(r,headr);

$gdxin small_data.gdx
$load headr
$load res_data_original=data
$gdxin
res_data(r,headr)=res_data_original(r,headr);
$gdxin rank.gdx
$load rank_original=data
$gdxin
rank(r,headr)=rank_original(r,headr);

$call csv2gdx apartments_new.csv id=Data autoRow=a values=1..lastCol useHeader=y

set apt_headr(*);
parameter apt_data(a, headr);

$gdxin apartments_new.gdx
$load apt_headr=Dim2
$load apt_data=Data
$gdxin

**********************************************************
$onText
notes on the normalization of budgets/prices:

* for residents, since we know the budget is generated from norm(1200,200), we simply scale it by 600, hence the mean would be 2;
* for apartment prices, we scale it by 600 too.

$offtext
scalar budget_mean "the mean value of the budget, get it from residents_data" /1200/;
* normalize the budget with mean value 2
res_data(r, 'budget') = 2*res_data(r, 'budget')/budget_mean;

apt_data(a,'budget') = 2*apt_data(a,'budget')/budget_mean;

***********************************************************

display res_data, rank;



set m "m1:drive, m2:walk, m3: drive" /m1*m3/;

parameter apt_com_t(a, m);

$gdxin apartments_new.gdx
$load apt_com_t=Data
$gdxin

********************** Format data **********************

set r_method(r,m) "include a (resident i, commute method j) pair in a set only if j is the preferred commute method of i";
r_method(r,m) = no;
r_method(r,m) $ (ord(m)=res_data(r,'com_m')) = yes;

display apt_data, apt_headr, apt_com_t;

parameter apt_com_t_nm(a,m) "binned commute time - put each commute time into 5-minute interval bins";

set slot /t1*t5/;
parameter time_slot(slot)
/t1 5,
 t2 10,
 t3 15,
 t4 20,
 t5 25/;
 
apt_com_t_nm(a,m) $ (apt_com_t(a, m)<time_slot('t1')) = 1;
apt_com_t_nm(a,m) $ (apt_com_t(a, m)>=time_slot('t1') and apt_com_t(a, m)<time_slot('t2')) = 2;
apt_com_t_nm(a,m) $ (apt_com_t(a, m)>=time_slot('t2') and apt_com_t(a, m)<time_slot('t3')) = 3;
apt_com_t_nm(a,m) $ (apt_com_t(a, m)>=time_slot('t3') and apt_com_t(a, m)<time_slot('t4')) = 4;
apt_com_t_nm(a,m) $ (apt_com_t(a, m)>=time_slot('t4') and apt_com_t(a, m)<time_slot('t5')) = 5;
apt_com_t_nm(a,m) $ (apt_com_t(a, m)>time_slot('t5')) = 6;

parameter
abs_diff(r,a,headr) "absolute difference between apartment a and and resident r",
abs_diff_cmt(r,a) "absolute difference of commute time between apartment a and resident r";

abs_diff(r,a,headr) = abs(apt_data(a, headr)-res_data(r, headr));
abs_diff_cmt(r,a) = abs(sum(m $ r_method(r,m), apt_com_t_nm(a,m)) -res_data(r,'com_t'));


********************** Model **********************

scalars
        infty "stand-in for infinity in equations" /1e5/;
        
parameter
        lambda "priority between minimizing average dissatisfaction and max dissatisfaction" /0.4/;

display infty;

free variables 
        avgdis "total dissatisfication",
        maxdis "dissatisfaction of most dissatisfied resident",
        dis(r) "dissatisfaction of resident r",
        cdis "combined dissatisfaction from average dissatisfaction and the most dissatisfied resident";

positive variables disAON(r) "dissatisfaction all or nothing - equals dis(r) if r is most dissatisfied resident and 0 otherwise";

binary variables
        b(r,a) "b(r,a)=1 if assign resident r to apartment i"
        d(r,m) "d(r, m)=1 if resident r choose method m",
        isMax(r) "is the resident who is most dissatisfied",
        isntMax(r) "isnt the resident who is most dissatisfied",
        worse(r,r2) "only able to be 1 if r is at least as dissatisfied as r2",
        better(r, r2) "must be 1 if r is less dissatisfied (=more satisfied) than r2";

equations
        obj "combine average and max dissatisfaction losses", 
        calcavgdis "average dissatisfaction",
        calcmaxdis "dissatisfaction of most dissatisfied resident",
        calcrdis(r) "calc dissatisfaction of resident r",
        findbetter(r,r2) "determine if r is happier than r2",
        findworse(r, r2) "if r is less happy from r2",
        calcIsntmax(r) "determine if r can potentially be the most dissatisfied resident",
        calcIsmax(r) "determine if r will be selected as most dissatisfied",
        mostdissed "choose only one resident as the most dissatisfied",
        disaon_lolim1(r) "disAON is 0 if r isnt most dissatisfied",
        disaon_lolim2(r) "disAON isnt greater than dis(r)",
        disaon_hilim(r) "disAON is dis(r) if r is most dissatisfied",
* constraints
        bound_1(r) "each apartment gets at most one resident", 
        bound_2(a) "each resident gets at most one apartment", 
        bound_3 "count the number of residents assigned apartments";



calcrdis(r)..
dis(r) =e= sum(a, b(r,a) * sum(headr, rank(r, headr)*abs_diff(r,a,headr)))
        + sum(a, b(r,a) * rank(r,'com_t')*abs_diff_cmt(r,a));
* second line is dissatisfaction with commute, first line is dissatisfaction with everything else

findbetter(r, r2)..
better(r, r2) =g= (dis(r2) - dis(r)) / infty;
* better(r2,r2)=0 or 1 not determined

findworse(r, r2)..
worse(r, r2) + better(r, r2) =e= 1;
* worse(r2,r2)=0 or 1 not determined 

calcIsntmax(r)..
isntMax(r) =g= 1/card(r) * (-sum(r2, worse(r,r2) ) + card(r));
* since worse(r2,r2) not determined, it is possible -sum(r2, worse(r,r2)) = -card(r) or -card(r)+1

calcIsmax(r)..
isMax(r) + isntMax(r) =e= 1;

mostdissed..
sum(r, isMax(r)) =e= 1;

disaon_lolim1(r)..
disAON(r) =l= infty * isMax(r);
* isMax(r) = 0 -> disAON(r) = 0

disaon_lolim2(r)..
0 =l= dis(r) - disAON(r);
* disAON(r) <= dis(r)

disaon_hilim(r)..
dis(r) - disAON(r) =l= infty * (1-isMax(r));
* isMax(r) = 1 -> disAON(r) >= dis(r)
        
bound_1(r)..
sum(a, b(r,a)) =l= 1;

bound_2(a)..
sum(r, b(r,a)) =l= 1;

bound_3..
sum((r,a), b(r,a)) =e= pairs;

calcavgdis..
avgdis =e= (1/card(r)) * sum(r, dis(r));

calcmaxdis..
maxdis =e= sum(r, disAON(r));

obj..
cdis =e= lambda*avgdis + (1-lambda)*maxdis;

model primary_model /all/;
solve primary_model using mip minimizing cdis;

parameter tradeoff_dis, tradeoff_assignment(r,a);

tradeoff_dis = cdis.l;
tradeoff_assignment(r,a) = b.l(r,a);

*************************** changing lambda ****************************
$onText
Comments:

Interestingly, the average dis and max dis does not change when lambda < 1,
i.e., them remain the same as long as lambda<1.

But when lambda=1, the average dis gets a little bit worse while the max dis
get worse significantly.

this implies the trade-off model works as expected: make the worst not so dissatisfied
while keep most of the people happy.
$offText

$onText
set iter /1*5/;

parameter iter_n "total number of iterations";

iter_n = card(iter);

parameter
lambda_options(iter),
tf_cdis(iter) "the combined dissatisfaction at iteration iter",
tf_avgdis(iter) "the averaged dissatisfaction at iteration iter",
tf_maxdis(iter) "the max dissatisfaction at iteration iter",
matching(iter) "matching at iteration iter";

lambda_options(iter) = ord(iter)/iter_n;
option SolPrint = off;
loop(iter,
    lambda = lambda_options(iter);
    solve primary_model using mip minimizing cdis;
    tf_cdis(iter) = cdis.l;
    tf_avgdis(iter) = avgdis.l;
    tf_maxdis(iter) = maxdis.l;
)

display tf_cdis, tf_avgdis, tf_maxdis, lambda;
$offText

********************* Extreme Inputs ************************
*option SolPrint = off;

* one abnormal resident
rank('1', headr) = 0;
rank('1', 'nbed') = 1;
display rank;
solve primary_model using mip minimizing cdis;

parameters cdis_s1, maxdis_s1, avgdis_s1;
cdis_s1 = cdis.l;
maxdis_s1 = maxdis.l;
avgdis_s1 = avgdis.l;

display cdis_s1, maxdis_s1, avgdis_s1;


* all residents have the same preference
parameter rank_1(headr);
rank_1(headr) = uniform(0,1);
alias(headr, h);
rank(r, headr) = rank_1(headr)/sum(h, rank_1(headr));
solve primary_model using mip minimizing cdis;

parameters cdis_s2, maxdis_s2, avgdis_s2;
cdis_s2 = cdis.l;
maxdis_s2 = maxdis.l;
avgdis_s2 = avgdis.l;

display cdis_s2, maxdis_s2, avgdis_s2;


* all residents wants 15min commute time
parameter rank_2(r, headr);
rank_2(r, headr) = 0;
rank_2(r, 'com_t') = 3;
rank(r, headr) = rank_2(r, headr);
solve primary_model using mip minimizing cdis;

parameters cdis_s3, maxdis_s3, avgdis_s3;
cdis_s3 = cdis.l;
maxdis_s3 = maxdis.l;
avgdis_s3 = avgdis.l;

display cdis_s3, maxdis_s3, avgdis_s3;

* all residents have some weird requests
res_data(r, 'nbed') = 0;
res_data(r, 'budget') = 500;

rank(r,headr)=rank_original(r,headr);

solve primary_model using mip minimizing cdis;

parameters cdis_s4, maxdis_s4, avgdis_s4;
cdis_s4 = cdis.l;
maxdis_s4 = maxdis.l;
avgdis_s4 = avgdis.l;

display cdis_s4, maxdis_s4, avgdis_s4;

res_data(r,headr)=res_data_original(r,headr);

************************ Stochastic Model ****************************
$onText
stochastic model details:

* match every resident registered in the past week to current apartments every Mon;
* each resident is assigned a register time, from 1-7, where 1 -> 1 day ago, 2 -> 2 days ago, etc.;
* for each register time, there is a pobability that the resident would quit before the matching process;
* this probability is set manually;
* if a resident quits, his/hers dissatisfication is set to 0; 
* the rest of the model remain unchanged;
 
$offText

set t week days /1*7/;

parameter regtim(r) "the registration time of each resident r";

regtim(r) = ceil(uniform(0,7));

parameter quitprob(t) "the probability of quitting on the t-th days after registration"
/1 0.05
 2 0.05
 3 0.7
 4 0.9
 5 0.12
 6 0.15
 7 0.18/;


equations
calcErdis(r,t) "calculate the expected dissatisfication of resident r";

calcErdis(r,t) $ (ord(t)=regtim(r))..
dis(r) =e= (1-quitprob(t))*sum(a, b(r,a) * sum(headr, rank(r, headr)*abs_diff(r,a,headr)))
        + (1-quitprob(t))*sum(a, b(r,a) * rank(r,'com_t')*abs_diff_cmt(r,a));
* second line is Expected dissatisfaction with commute, first line is expected dissatisfaction with everything else


model sto_model /obj, calcavgdis, calcmaxdis, calcErdis, findbetter, findworse, calcIsntmax,
                calcIsmax, mostdissed, disaon_lolim1, disaon_lolim2, disaon_hilim, bound_1, 
                bound_2, bound_3/;
                
solve sto_model using mip minimizing cdis;

parameter
sto_dis "(combined/final) dissatisfication in the stochastic model",
sto_assignment(r,a) "apartment assignment in the stochastic model";

sto_dis = cdis.l;
sto_assignment(r,a) = b.l(r,a);

display tradeoff_dis, sto_dis, tradeoff_assignment, sto_assignment;








